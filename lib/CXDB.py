import logging

from playwright.sync_api import sync_playwright, Page
from time import sleep, time
import yaml
import shutil
from pathlib import Path
import os
import subprocess
from datetime import datetime
import platform


class CXDB:
    PROD_ANNOUNCEMENT_DIALOG_BTN = '[data-testid="announcement-dialog-button"]'
    WORKSPACE_SEARCH_FIELD = '[data-testid="search-with-dropdown-input"]'
    WORKSPACE_ROOMLIST_CHAT_TAB = '[data-testid="workspace-room-list-tab-chat"]'
    WORKSPACE_ROOMLIST_CONTACT_TAB = '[data-testid="workspace-room-list-tab-contact"]'
    WORKSPACE_ROOMLIST_CALL_TAB = '[data-testid="workspace-room-list-tab-call"]'
    WORKSPACE_SEARCH_CONTACT_CHIP = '[data-testid="search-workspace-filter-contact"]'
    WORKSPACE_SEARCH_CHATROOM_CHIP = '[data-testid="search-workspace-filter-chatroom"]'
    WORKSPACE_CONTACT_PROFILE_CHAT_BTN = '[data-testid="profile-direct-im"]'
    WORKSPACE_CONTACT_PROFILE_CALL_BTN = '[data-testid="profile-direct-call"]'
    WORKSPACE_CALLS_DIALPAD_CALL_BTN = '[data-testid="dial-pad-call"]'

    def __init__(self, playwright: sync_playwright, har_filename, logger):
        config_log = yaml.load(open('config.yaml'), Loader=yaml.FullLoader)['logger']
        har_folder = config_log['har_folder']
        self.ping_file = f'{har_filename[:-4]}.txt'
        self.lgr = logger
        self.videos_path = 'videos'
        size1 = {'width': 1920, 'height': 900}      # window size for testing
        size2 = {'width': 1536, 'height': 720}      # window size for video recording, file size reduce 1/2
        browser_args = ['--use-fake-device-for-media-stream', '--use-fake-ui-for-media-stream', '--no-sandbox', '--disable-gpu', '--disable-extensions']
        self.browser = playwright.chromium.launch(headless=False, args=browser_args, channel='chrome')
        self.context = self.browser.new_context(record_video_dir=self.videos_path, viewport=size1, record_har_path=f'{har_folder}/{har_filename}', record_har_content='embed', record_video_size=size2)
        self.page = self.context.new_page()
        self.page.on('console', self.on_console)
        self.video_name = self.page.video.path()    # get video filename generated by playwright

    def on_console(self, console_message):
        if console_message.type == 'error':
            self.lgr.error(f"console {console_message.type}: {console_message.text}")
        elif console_message.type == 'warning':
            self.lgr.warning(f"console {console_message.type}: {console_message.text}")
        else:
            self.lgr.info(f"console {console_message.type}: {console_message.text}")

    def video_rename(self, new_name):
        shutil.move(self.video_name, Path(self.videos_path).joinpath(new_name))     # file rename

    def video_remove(self):
        if os.path.exists(self.video_name):     # check file exists
            os.remove(self.video_name)

    def ping_record(self, host, flag):
        os_type = platform.system()
        command, line, line_wrap = (['ping', '-n', '1', host], 2, '') if os_type == 'Windows' else (['ping', '-c', '1', host], 1, '\n')

        while flag[0]:
            process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            output, error = process.communicate()
            output_str = output.decode('utf-8')
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            with open(f'ping_record/{self.ping_file}', 'a') as pf:
                if len(output_str.split('\n')) > 2:
                    result = output_str.split('\n')[line]
                else:
                    result = output_str
                pf.write(f'[{timestamp}] {result}{line_wrap}')
            sleep(1)

    def remove_ping_record(self):
        if os.path.exists(f'ping_record/{self.ping_file}'):     # check file exists
            os.remove(f'ping_record/{self.ping_file}')

    def login_cxdb(self, cxdb_url, account, password):
        start_time = time()
        self.page.goto(cxdb_url)
        self.page.locator('[data-testid="email"]').fill(account)
        self.page.fill('[data-testid="password"]', password)
        self.page.click('[data-testid="login-button"]')
        self.lgr.info(f'<{account}> logged in CXDB.')

        # self.page.wait_for_load_state('domcontentloaded')

        try_max_times = 18
        for i in range(try_max_times):
            if self.page.is_visible('[data-testid="get-started-menu"] ~ div button'):
                self.lgr.info('click here button is displayed.')
                break
            else:
                self.lgr.error(f'try {i+1} times, the click here button is not displayed.')
                if i != try_max_times - 1:
                    if i < 15:
                        sleep(2)
                    else:
                        sleep(10)
                else:
                    self.lgr.error(f'welcome page cannot load complete in {i * (2 if i < 15 else 18)} seconds')
                    assert False

        end_time = time()
        load_time = round(end_time - start_time, 3)
        self.lgr.info(f'Login spent {load_time} seconds')

    def check_announcement(self):
        try:
            if self.page.wait_for_selector(self.PROD_ANNOUNCEMENT_DIALOG_BTN, timeout=3000):
                self.lgr.info(f'Find announcement for this test')
                self.page.click(self.PROD_ANNOUNCEMENT_DIALOG_BTN)
        except:
            self.lgr.info(f'No announcement for this test')


    def goto_workspace(self, cxdb_url):
        '''
            Open Workspace page
        '''
        try_refresh_times = 0
        try_refresh_max_times = 2

        while try_refresh_times <= try_refresh_max_times:
            start_time=time()
            if try_refresh_times != try_refresh_max_times:
                self.page.goto(f'{cxdb_url}/#/agent-home')
                logging.info(f'navigate to workspace page {try_refresh_times+1} time(s)')
                try:
                    self.page.is_enabled('css=[data-testid="open-create-list-button"]')
                    self.page.wait_for_load_state('networkidle')
                    end_time = time()
                    load_time = round(end_time - start_time, 3)
                    logging.info(f'Loaded workspace sucessfully, took {load_time} seconds')
                    break
                except:
                    end_time = time()
                    load_time = round(end_time - start_time, 3)
                    logging.info(f'Loaded workspace failed, took {load_time} seconds')
                    try_refresh_times += 1
            else:
                logging.error(f'try to navigate to workspace page {try_refresh_max_times} times, but the page cannot be loaded')
                assert False

    def search_staff_chatroom(self, staff_name):
        self.page.fill(self.WORKSPACE_SEARCH_FIELD, staff_name)  # input staff name in search field
        self.page.keyboard.press('Enter')  # press Enter to search
        self.page.click(self.WORKSPACE_SEARCH_CONTACT_CHIP)  # click contact (because chatroom is not established if staff not chat ever)
        self.page.click(f'text={staff_name}')       # click contact name to show profile panel
        self.page.click(self.WORKSPACE_CONTACT_PROFILE_CHAT_BTN)   # click chat icon
        self.page.click(self.WORKSPACE_SEARCH_CHATROOM_CHIP)      # click chatroom to prevent repeat click contact name and prompt profile panel
        sleep(2)

    def make_an_onnet_call_to_staff(self, staff_name: str):
        """
        Search staff, open chatroom and make onnet call

        :param staff_name: Staff name, better a unique name for search result
        """
        self.page.click(self.WORKSPACE_ROOMLIST_CONTACT_TAB)
        self.page.fill(self.WORKSPACE_SEARCH_FIELD, staff_name)
        self.lgr.info(f'Searching... <{staff_name}>')
        self.page.keyboard.press('Enter')
        sleep(2.0)

        self.page.click('css=[data-testid="avatar-icon-badge"]')
        self.page.click(self.WORKSPACE_CONTACT_PROFILE_CALL_BTN)
        sleep(1.0)
        self.page.wait_for_selector('css=[class="Progress"]', state='detached')
        self.lgr.info(f'Make Onnet Call to <{staff_name}>')

    def make_offnet_call_via_dialpad(self, country_code='886', phone_number='903212095'):
        '''
            Off-net call to PSTN number from keypad
        '''
        self.page.click(self.WORKSPACE_ROOMLIST_CALL_TAB)    # Calls tab
        sleep(3.0)
        # self.page.click('css=[data-testid="phone-number-country-selector"]')  # Country code selector
        # sleep(1)
        # self.page.type('css=[data-testid="phone-number-country-selector"]', country_code)    # Type in country code
        # sleep(1)
        # self.page.click('css=[data-option-index="0"]') # Select first option
        self.page.fill('css=[data-testid="phone-number-input"]', f'+886{phone_number}')
        # element = self.page.locator('css=[data-testid="phone-number-input"]')
        # element.set_attribute('value', f'+{phone_number}')
        sleep(1)
        ### Select different CLI
        # self.page.click('css=[class="font-icon-right font-size-20"]')   # CLI Select >
        # # self.page.click('css=[class="cli-selector__list__area"]:last-child [class="cli-selector__item"]')   # select unselected cli
        self.page.click(self.WORKSPACE_CALLS_DIALPAD_CALL_BTN)  # Keypad - Call button
        sleep(1)
        self.lgr.info(f'Make Offnet Call to <{country_code}{phone_number}>')

    def db_action_in_audio_callview(self, action_button):
        """In the CXDB callview, click the button
            Args:
                action_button (str): EndCall / Video / Mute / Hold / Record / Keypad / HideKeypad / WarmTransfer / BlindTransfer
            Returns:
                None
        """
        try:
            match action_button:
                case "EndCall":
                    self.page.click('css=[data-testid="call-end"]')
                case "Video":
                    self.page.click('css=[data-testid="call-video"]')
                case "Mute":
                    self.page.click('css=[data-testid="call-mute"]')
                case "Hold":
                    self.page.click('css=[data-testid="call-mute"]')
                case "Record":
                    self.page.click('css=[data-testid="call-more"]')
                    self.page.click('css=[data-testid="call-record"]')
                case "Keypad":
                    self.page.click('css=[data-testid="call-more"]')
                    self.page.click('css=[data-testid="call-keypad"]')
                case "HideKeypad":
                    self.page.click('css=[data-testid="call-hide-keypad"]' )
                case "WarmTransfer":
                    self.page.click('css=[data-testid="call-transfer"]')
                    self.page.click('css=[data-testid="transfer-menu-warmTransfer-menu-item"]')
                case "BlindTransfer":
                    self.page.click('css=[data-testid="call-transfer"]')
                    self.page.click('css=[data-testid="transfer-menu-blindTransfer-menu-item"]')
            self.lgr.info(f'Clicked "{action_button}" button')
        except Exception as e:
            self.lgr.info(f'Failed to click "{action_button}" button')
            assert False

    def open_call_log(self, callee=True, get_call_id=True):

        if callee == True:
            view_call_log_locator = 'css=[datatestid="chat-message-received-call-button-more-actions"]'  # callee on the left side
        else:
            view_call_log_locator = 'css=[datatestid="chat-message-sended-call-button-more-actions"]'    # caller on the right side

        total_call_logs = self.page.locator(view_call_log_locator)
        if get_call_id == True:
            try:
                total_call_logs.last.click()  # get the total call log
                self.page.click('css=[data-testid="copy-call-id-button"]')     # copy call id
                self.page.click('css=[data-testid="CloseIcon"]')    # x button of call log
            except:
                self.lgr.info(f'Something went wrong when trying to copy the call ID.')
        else:
            pass    # leave it opened, no other action currently

    def send_msg_to_staff(self, staff_name, message):
        self.page.click(f'text={staff_name}')
        self.page.fill('[data-testid="chatroom-editor"] div.public-DraftStyleDefault-block', message)  # fill text in input field
        self.page.click('[data-testid="send-message"]')  # click send button
        self.lgr.info(f'send message to <{staff_name}>.')
        sleep(5)

    def verify_the_last_msg(self, message, receiver=True):
        # locator = 'div.message-panel__current-room-history > div > :last-child > :last-child  [data-testid="message-sender-text-content"] > span'
        if receiver == True:
            msg_locator = '[data-testid="message-receiver-text-content"]'
            staff = "receiver"
        else:
            msg_locator = '[data-testid="message-sender-text-content"]'
            staff = "sender"
        msg_locators = self.page.query_selector_all(msg_locator)
        if message == msg_locators[-1].inner_text():
            self.lgr.info(f'cxdb {staff} message validation passed.')
        else:
            self.lgr.info(f'cxdb {staff} message validation failed.')
            assert False

    def verify_the_last_msg_sender(self, message):
        # locator = 'div.message-panel__current-room-history > div > :last-child > :last-child  [data-testid="message-sender-text-content"] > span'
        msg_locator = '[data-testid="message-sender-text-content"]'
        msg_locators = self.page.query_selector_all(msg_locator)
        if message == msg_locators[-1].inner_text():

            self.lgr.info('cxdb message validation passed.')
        else:
            self.lgr.info('cxdb message validation failed.')
            assert False

    def verify_the_last_msg_receiver(self, message):
        # locator = 'div.message-panel__current-room-history > div > :last-child > :last-child  [data-testid="message-receiver-text-content"] > span'
        msg_locator = '[data-testid="message-receiver-text-content"]'
        msg_locators = self.page.query_selector_all(msg_locator)
        if message == msg_locators[-1].inner_text():
            self.lgr.info('cxdb message validation passed.')
        else:
            self.lgr.info('cxdb message validation failed.')
            assert False

    def send_image_to_staff(self, staff_name, file_path):
        self.page.click(f'text={staff_name}')
        self.page.set_input_files('[data-testid="input-panel-upload-file"]', file_path)  # attach image
        self.page.click('[data-testid="ongoing-room-input-panel-input-panel-children-and-right"] button')  # click send button
        self.lgr.info(f'send image to <{staff_name}>.')
        sleep(5)

    def verify_the_last_image(self, file_path, receiver=True):
        # locator = 'div.message-panel__current-room-history > div > :last-child > :last-child img'
        if receiver == True:
            locator = '[data-testid="message-receiver-media-content"]'
            staff = "receiver"
        else:
            locator = '[data-testid="message-sender-media-content"]'
            staff = "sender"
        try_max_times = 3
        try_times = 0
        while True:
            if self.page.is_visible(locator):
            # if file_path.split('/')[-1] == self.page.get_attribute(locator, 'alt'):
                self.lgr.info(f'cxdb {staff} image validation passed.')
                break
            else:
                if try_times != try_max_times:
                    self.lgr.info(f'cxdb {staff} image validation failed, retry {try_times+1} time(s).')
                    try_times += 1
                    sleep(10)
                else:
                    self.lgr.info(f'cxdb {staff} image validation failed.')
                    assert False

    def send_file_to_staff(self, staff_name, file_path):
        self.page.click(f'text={staff_name}')
        self.page.set_input_files('[data-testid="input-panel-upload-file"]', file_path)  # attach file
        self.page.click('[data-testid="ongoing-room-input-panel-input-panel-children-and-right"] button')  # click send button
        self.lgr.info(f'send file to <{staff_name}>.')
        sleep(5)

    def verify_the_last_file(self, file_path, receiver=True):
        # locator = 'div.message-panel__current-room-history > div > :last-child > :last-child [data-testid="im-file-download"] > :last-child > :first-child'
        locator = '//*[@data-testid="im-file-download-icon-btn"]/../../div/p[1]'
        if receiver == True:
            staff = "receiver"
        else:
            staff = "sender"
        file_name_locators = self.page.query_selector_all(locator)
        # self.lgr.info(f'file name {file_name_locators[-1].inner_text()}')
        if file_path.split('/')[-1] == file_name_locators[-1].inner_text():
            self.lgr.info('cxdb file validation passed.')
        else:
            self.lgr.info('cxdb file validation failed.')
            assert False

    def send_audio_note_to_staff(self, staff_name, record_seconds):
        self.page.click(f'text={staff_name}')
        self.page.click('[data-testid="audio-note"]')  # click audio note button
        sleep(record_seconds)
        self.page.click('[data-testid="record-done"]')  # click record done button
        self.lgr.info(f'send audio note to <{staff_name}>.')
        sleep(5)

    def verify_the_last_audio_note(self, receiver=True):
        # locator = 'div.message-panel__current-room-history > div > :last-child > :last-child [data-testid="audio-file-message-received"]'
        if receiver == True:
            audio_note_locator = '[data-testid="audio-file-message-received"]'
            staff = "receiver"
        else:
            audio_note_locator = '[data-testid="audio-file-message-sended"]'
            staff = "sender"
        audio_note_locators = self.page.query_selector_all(audio_note_locator)
        if audio_note_locators[-1].is_visible():
            self.lgr.info(f'cxdb {staff} audio note validation passed.')
        else:
            self.lgr.info(f'cxdb {staff} audio note validation failed.')
            assert False

    def verify_the_last_audio_note_sended(self):
        # locator = 'div.message-panel__current-room-history > div > :last-child > :last-child [data-testid="audio-file-message-received"]'
        audio_note_locator = '[data-testid="audio-file-message-sended"]'
        audio_note_locators = self.page.query_selector_all(audio_note_locator)
        if audio_note_locators[-1].is_visible():
            self.lgr.info(f'cxdb sender audio note validation passed.')
        else:
            self.lgr.info(f'cxdb sender audio note validation failed.')
            assert False

    def verify_the_last_audio_note_received(self):
        # locator = 'div.message-panel__current-room-history > div > :last-child > :last-child [data-testid="audio-file-message-received"]'
        audio_note_locator = '[data-testid="audio-file-message-received"]'
        audio_note_locators = self.page.query_selector_all(audio_note_locator)
        if audio_note_locators[-1].is_visible():
            self.lgr.info('cxdb receiver audio note validation passed.')
        else:
            self.lgr.info('cxdb receiver audio note validation failed.')
            assert False

    def pick_up_chat_inquiry(self):
        self.page.click('[data-testid="enquiry-centre-btn"]')
        # self.page.click('div.pending-inquiry-list__item')
        self.page.click('[data-testid="pending-inquiry-content"]')
        self.lgr.info('staff pick up the inquiry')
        sleep(3)

    def staff_pick_up_call(self, retry=3):
        call_log_available = False
        self.page.wait_for_selector('css=[data-testid="call-answer"]', timeout=30000)
        while retry > 0:
            try:
                self.lgr.info(f'Trying to pick up the incoming call: Attempt number: {4 - retry}')
                self.page.click('css=[data-testid="call-answer"]')
                sleep(1.0)
                self.lgr.info('Staff click Accept Call button')
                self.page.wait_for_selector('css=[data-testid="call-answer"]', state='detached')
                self.page.wait_for_selector('css=[class="Progress"]', state='detached')
                self.page.is_enabled('css=[data-testid="call-end"]')
                self.lgr.info('Switched to Audio call view')
                call_log_available = True
                return call_log_available
            except Exception as e:
                self.lgr.error(f'Attempt number: {4 - retry} Staff failed to accept the call. Error: {str(e)}')
                retry -= 1
                if retry == 0:
                    return call_log_available

    def db_verify_whether_call_is_connected(self, browserName, timeout=30):
        call_log_available = False
        db_duration_locator = 'css=[data-testid="call-timer"]'
        for _ in range(timeout):
            if self.page.is_visible(db_duration_locator):
                duration_min = self.page.text_content(db_duration_locator)[0:2]
                duration_sec = self.page.text_content(db_duration_locator)[3:5]
                self.lgr.info(f'{browserName}: Call duration >>> {duration_min}:{duration_sec}')
                call_log_available = True
                break

            if not call_log_available:
                self.lgr.info(f'{browserName}: Waiting for pickup...')
            sleep(1.0)

        if not call_log_available:
            self.lgr.info(f'{browserName}: Call is not connected.')

        return call_log_available

    def db_verify_whether_offnet_is_connected(self, browserName, timeout=30):
        call_log_available = False
        db_duration_locator = 'css=[data-testid="call-timer"]'
        for _ in range(timeout):
            if self.page.is_visible(db_duration_locator):
                duration_min = self.page.text_content(db_duration_locator)[0:2]
                duration_sec = self.page.text_content(db_duration_locator)[3:5]
                self.lgr.info(f'{browserName}: Call duration >>> {duration_min}:{duration_sec}')
                call_log_available = True
                break

            if not call_log_available:
                self.lgr.info(f'{browserName}: Waiting for pickup...')
            sleep(1.0)

        if not call_log_available:
            self.lgr.info(f'{browserName}: The PSTN Call is not connected.')
            self.db_action_in_audio_callview('EndCall')
            self.lgr.info('Hang up the call because the call is not picked up in 30 seconds.')

        return call_log_available

    # def verify_whether_call_is_alive(self, timeout=10):
    #     call_log_available = False
    #     duration_locator = 'css=[data-testid="call-timer"]'
    #     duration_min = self.page.text_content(duration_locator)[0:2]
    #     duration_sec = self.page.text_content(duration_locator)[3:5]
    #     while (not duration_min.isdigit()):
    #         timeout -= 1
    #         sleep(1.0)
    #         duration_min = self.page.text_content(duration_locator)[0:2]
    #         duration_sec = self.page.text_content(duration_locator)[3:5]
    #         if timeout == 0:
    #             if self.page.is_visible('css=[data-testid="call-end"]'):
    #                 self.page.click('css=[data-testid="call-end"]')
    #             self.lgr.info('The call is not connected')
    #             assert False
    #
    #     call_log_available = True
    #     if int(duration_min) == 0:
    #         self.lgr.info(f'Verified the call is connected')
    #     else:
    #         self.lgr.info(f'The call is last for {duration_min}:{duration_sec}')
    #
    #     return call_log_available
    #
    # def verify_whether_offnet_is_picked_up(self, timeout=15):
    #     call_log_available = False
    #     duration_locator = 'css=[data-testid="call-timer"]'
    #     duration_min = self.page.text_content(duration_locator)[0:2]
    #     duration_sec = self.page.text_content(duration_locator)[3:5]
    #     while (not duration_min.isdigit()):
    #         timeout -= 1
    #         sleep(1.0)
    #         duration_min = self.page.text_content(duration_locator)[0:2]
    #         duration_sec = self.page.text_content(duration_locator)[3:5]
    #         if timeout == 0:
    #             self.db_action_in_audio_callview('EndCall')
    #             self.lgr.info('The PSTN call is not connected')
    #             assert False
    #
    #     call_log_available = True
    #     if int(duration_min) == 0:
    #         self.lgr.info(f'Verified the PSTN call is connected')
    #     else:
    #         self.lgr.info(f'The PSTN call is last for {duration_min}:{duration_sec}')
    #
    #     return call_log_available

    def staff_close_inquiry(self):
        self.page.click('[data-testid="room-header-submenu"]')
        sleep(2.0)
        self.page.click('[data-testid="more-menu-close-inquiry-this-room-menu-item"]')
        sleep(2.0)
        self.page.click('[data-testid="confirm-button"]')
        self.lgr.info('staff close the inquiry')
        sleep(3.0)

    def send_remote_log(self):
        logging.info('send remote log')

        # method 1: click directly
        # self.page.click('[data-testid="send-remote-log-button"]')

        # method 2: run js
        js_script = """async () => {const sendLogButton = document.querySelector('[data-testid="send-remote-log-button"]')

            if (sendLogButton) {
              sendLogButton.click();
              await window.remoteLogSpace.promise;
              return "resolve";
            }

            return "reject";}"""
        try:
            status = self.page.evaluate(js_script)
            logging.info(f'send remote log status: {status}')
            sleep(5)
        except:
            logging.info('exception during send remote log...')

    def close(self):
        self.browser.close()
